//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Include guards
#ifndef OOMPH_PRECONDITION_HEADER
#define OOMPH_PRECONDITION_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "matrices.h"
#include "problem.h"
#include <algorithm>



namespace oomph
{

//=============================================================================
/// \short Preconditioner base class. This is a base class for all oomph-lib
/// preconditioners and primarily contains the method definitions. All 
/// preconditioners should be derived from this class.
//=============================================================================
 class Preconditioner : public DistributableLinearAlgebraObject
{

 public:

  /// Constructor
  Preconditioner() : Problem_pt(0), Matrix_pt(0) {};

 /// Broken copy constructor
 Preconditioner(const Preconditioner&) 
  { 
   BrokenCopy::broken_copy("Preconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const Preconditioner&) 
  {
   BrokenCopy::broken_assign("Preconditioner");
  }

  /// Destructor (empty)
  virtual ~Preconditioner(){}

  /// \short Apply the preconditioner. Pure virtual generic interface
  /// function. This method should apply the preconditioner operator to the
  /// vector r and return the vector z.
  virtual void preconditioner_solve(const DoubleVector &r, DoubleVector &z)
  = 0;

  /// \short Setup the preconditioner: store problem and matrix pointer then
  /// call preconditioner specific setup() function.
  virtual void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt)
   {
   set_problem_pt(problem_pt);
   set_matrix_pt(matrix_pt);
   setup();
  }

  /// \short Setup the preconditioner. Pure virtual generic interface
  /// function. Allows preconditioner to be assembled based on the Problem
  /// or the assembled matrix
  virtual void setup() = 0;

  /// \short Clean up memory (empty). Generic interface function.
  virtual void clean_up_memory(){};

  // Access functions
  // ============================================================

  /// Get function for matrix pointer.
  DoubleMatrixBase* matrix_pt() const
  {
#ifdef PARANOID
   if(Matrix_pt == 0)
    {
     std::ostringstream error_msg;
     error_msg << "Matrix pointer is null.";
     throw OomphLibError(error_msg.str(),
                         "BlockPreconditioner::matrix_pt()",
      OOMPH_EXCEPTION_LOCATION);
   }
#endif
   return Matrix_pt;
  }
  
  /// \short Set the matrix pointer.
  void set_matrix_pt(DoubleMatrixBase* matrix_pt) {Matrix_pt = matrix_pt;}

  /// Get function for problem pointer.
  Problem* problem_pt() const
   {
#ifdef PARANOID
   if(Problem_pt == 0)
    {
     std::ostringstream error_msg;
     error_msg << "Problem pointer is null.";
     throw OomphLibError(error_msg.str(),
                         "BlockPreconditioner::problem_pt()",
      OOMPH_EXCEPTION_LOCATION);
   }
#endif
   return Problem_pt;
  }
  
  /// Set function for problem pointer.
  void set_problem_pt(Problem* problem_pt) {Problem_pt = problem_pt;}

 private:

  /// Storage for a pointer to the problem.
  Problem* Problem_pt;

  /// Storage for a pointer to the matrix.
  DoubleMatrixBase* Matrix_pt;

};//Preconditioner


//=============================================================================
/// The Identity Preconditioner
//=============================================================================
class IdentityPreconditioner : public Preconditioner
 {

   public:
  
  // Constructor - nothing to construct
  IdentityPreconditioner() {}
  
  /// Broken copy constructor
  IdentityPreconditioner(const IdentityPreconditioner&) 
   { 
    BrokenCopy::broken_copy("IdentityPreconditioner");
   } 
  
  /// Broken assignment operator
  void operator=(const IdentityPreconditioner&) 
   {
    BrokenCopy::broken_assign("IdentityPreconditioner");
   }

  /// Destructor (empty)
  virtual ~IdentityPreconditioner(){}

  /// setup method - just sets the distribution
  virtual void setup()
   {
    // first attempt to cast to DistributableLinearAlgebraObject
    DistributableLinearAlgebraObject* dist_matrix_pt = 
    dynamic_cast<DistributableLinearAlgebraObject*>(matrix_pt());
    
    // if it is a distributable matrix
    if (dist_matrix_pt != 0)
     {
      // store the distribution
      this->build_distribution(dist_matrix_pt->distribution_pt());
     }
    
    // else it is not a distributable matrix
    else
     {
      // # of rows in the matrix
     unsigned n_row=matrix_pt()->nrow();

     // Use a dummy (null) communicator_pt - should be ok because this is
     // only for the non-distributed case anyway...
     LinearAlgebraDistribution dist(0,n_row,false);
      this->build_distribution(dist);
     }
   }
  
  /// \short Apply the preconditioner. This method should apply the 
  /// preconditioner operator to the vector r and return the vector z.
  virtual void preconditioner_solve(const DoubleVector&r, DoubleVector &z)
   {
#ifdef PARANOID
    if (*r.distribution_pt() != *this->distribution_pt())
   {
    std::ostringstream error_message_stream;
    error_message_stream 
     << "The r vector must have teh same distribution as the preconditioner. "
     << "(this is the same as the matrix passed to setup())";
    throw OomphLibError
     (error_message_stream.str(),
      "IdentityPreconditioner::preconditioner_solve()",
      OOMPH_EXCEPTION_LOCATION);
   }
  if (z.built())
   {
    if (*z.distribution_pt() != *this->distribution_pt())
     {
      std::ostringstream error_message_stream;
      error_message_stream 
       << "The z vector distribution has been setup; it must have the "
       << "same distribution as the r vector (and preconditioner).";
      throw OomphLibError
       (error_message_stream.str(),
        "IdentityPreconditioner::preconditioner_solve()",
        OOMPH_EXCEPTION_LOCATION);
     }
   }
#endif

    // apply
    z=r;
   }
 };  
}

#endif
