//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//A header file that is used to define the oomph-lib Vector class

//Include guards to prevent multiple inclusions of the header
#ifndef OOMPH_VECTOR_HEADER
#define OOMPH_VECTOR_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Standard library includes
#include<vector>
#include<sstream>

//Oomph-libe error handler
#include "oomph_definitions.h"


namespace oomph
{


//===========================================================================
/// A slight extension to the standard template vector class so that
/// we can include "graceful" array range checks if the RANGE_CHECKING
/// flag is set. The generalisation to general allocators is NOT handled here, 
/// mainly because we never use it, but also because the intel and gnu 
/// compilers have different names for the internal classes, which makes 
/// writing code that works for both a pain!
//===========================================================================
template<class _Tp>
class Vector: public std::vector<_Tp>
{

public:
 
 /// Typedef to make the constructors look a bit cleaner
 typedef _Tp 						value_type;

 /// Typedef to make the constructors look a bit cleaner
 typedef value_type& 					reference;

 /// Typedef to make the constructors look a bit cleaner
 typedef const value_type& 				const_reference;

 /// Typedef to make the constructors look a bit cleaner
 typedef size_t 					size_type;

//Only include this code, if we are range checking
#ifdef RANGE_CHECKING
private:

 //Function to return a reference to a vector entry, 
 //including array range checking 
 reference error_checked_access(size_type __n)
  {
   //If there is an out of range error, die, but issue a warning message
   if (__n>=this->size())
    {
     //Construct an error message, as a string stream
     std::ostringstream error_message;
     error_message << "Range Error: " << __n 
                   << " is not in the range (0," 
                   << this->size()-1 << ")"; 
 
     //Throw an Oomph-lib error
     throw OomphLibError(error_message.str(),"Vector::error_checked_access",
                         OOMPH_EXCEPTION_LOCATION);
     
     //This is a dummy return to keep the Intel compiler happy
     return std::vector<_Tp>::operator[](__n);
    }
   else
    {
     return std::vector<_Tp>::operator[](__n);
    }
  }

 //Function to return a constant reference to a vector entry
 //including error range checking
  const_reference error_checked_access(size_type __n) const
  {
   //If there is an out of range error, die, but issue a warning message
   if (__n>=this->size())
    {
     //Construct an error message, as a string stream
     std::ostringstream error_message;
     error_message << "Range Error: " << __n 
                   << " is not in the range (0," 
                   << this->size()-1 << ")";
     
     //Throw an Oomph-lib error
     throw OomphLibError(error_message.str(),"Vector::error_checked_access",
                         OOMPH_EXCEPTION_LOCATION);

     //This is a dummy return to keep the Intel compiler happy
     return std::vector<_Tp>::operator[](__n);
    }
   else
    {
     return std::vector<_Tp>::operator[](__n);
    }
  }

#endif

public:
 
 //Standard Constuctors (some have been omitted from the stl classes)

 /// Construct an empty vector 
 Vector() : std::vector<_Tp>() {}
 
 /// \short A constructor that creates a vector of size __n.
 /// Note the use of explicit for "strong" type checking
 explicit Vector(size_type __n) : std::vector<_Tp>(__n) { }

 /// \short A constructor that creates a vector of size __n and 
 /// initialises every entry to __value
 Vector(size_type __n, const _Tp& __value) : std::vector<_Tp>(__n,__value) {}

 /// Copy constructor
 Vector(const Vector<_Tp>& __x) : std::vector<_Tp>(__x) {}

 //No explicit destructor is required because the base class destructor handles
 //all memory issues
 //~Vector() {}

 /// Iterate over all values and set to the desired value
 void initialise(const _Tp& __value)
  {
   for(typename std::vector<_Tp>::iterator it = std::vector<_Tp>::begin();
       it != std::vector<_Tp>::end(); it++)
    {
     *it = __value;
    }
  }

#ifdef RANGE_CHECKING
 /// Overload the bracket access operator to include array-range checking
 /// if the RANGE_CHECKING flag is set
 reference operator[](size_type __n) 
  {
   return error_checked_access(__n);
  }
 
 /// Overloaded, range-checking, bracket access operator (const version)
 const_reference operator[](size_type __n) const 
  {
   return error_checked_access(__n);
  }
#endif

};

//==================================================================
///\short A Vector of bools cannot be created because the is no
///compiler-independent  implementation of the bit manipulators.
///Making all the constructors private should lead to compile-time
///errors. 
//=================================================================
template<>
class Vector<bool>: private std::vector<bool>
{

public:
 
 /// Typedef to make the constructors look a bit cleaner
 typedef bool 						value_type;

 /// Typedef to make the constructors look a bit cleaner
 typedef value_type& 					reference;

 /// Typedef to make the constructors look a bit cleaner
 typedef const value_type& 				const_reference;

 /// Typedef to make the constructors look a bit cleaner
 typedef size_t 					size_type;


 /// \short Dummy constructor to avoid compiler from warning about
 /// only-private constructors
 Vector(const double& dont_call_this_constructor) 
  {
   //Throw an Oomph-lib error
   throw OomphLibError("Please use vector<bool> instead of Vector<bool>",
                       "Vector:: dummy constructor",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 private:
 
 //Standard Constuctors (some have been omitted from the stl classes)

 /// Construct an empty vector 
 Vector() : std::vector<bool>() {}
 
 /// \short A constructor that creates a vector of size __n.
 /// Note the use of explicit for "strong" type checking
 explicit Vector(size_type __n) : std::vector<bool>(__n) { }

 /// \short A constructor that creates a vector of size __n and 
 /// initialises every entry to __value
 Vector(size_type __n, const bool& __value) : std::vector<bool>(__n,__value) {}

 /// Copy constructor
 Vector(const Vector<bool>& __x) : std::vector<bool>(__x) {}

 /// Iterate over all values and set to the desired value
 void initialise(const bool& __value)
  {
   for(std::vector<bool>::iterator it = std::vector<bool>::begin();
       it != std::vector<bool>::end(); it++)
    {
     *it = __value;
    }
  }

};

}

#endif
