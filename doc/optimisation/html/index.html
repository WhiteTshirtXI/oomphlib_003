<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>oomph-lib</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="doxygen.css">
<link rel="stylesheet" type="text/css" href="../../oomph_header.css">
<!-- The  following script does the hide/show trick-->
<script language="JavaScript" type="text/javascript" 
        src="../../navbar_toggle.js" >
</script>
<!-- The  following script
 ensures that the required field on the download form get filled in-->
<script language="JavaScript">
<!--
function formCheck(formobj){
    // mandatory fields
    var fieldRequired = Array("name", "affiliation", "email", "why");
    // description to appear in the dialog box
    var fieldDescription = Array("name", "affiliation", "email", 
                                 "Why are you interested in oomph-lib?");
    // dialog message
    var alertMsg = "Please complete the following fields:\n";
    var l_Msg = alertMsg.length;
    for (var i = 0; i < fieldRequired.length; i++){
        var obj = formobj.elements[fieldRequired[i]];
        if (obj){
            switch(obj.type){
            case "select-one":
                if (obj.selectedIndex == -1 || 
                    obj.options[obj.selectedIndex].text == ""){
                    alertMsg += " - " + fieldDescription[i] + "\n";
                }
                break;
            case "select-multiple":
                if (obj.selectedIndex == -1){
                    alertMsg += " - " + fieldDescription[i] + "\n";
                }
                break;
            case "text":
            case "textarea":
                if (obj.value == "" || obj.value == null){
                    alertMsg += " - " + fieldDescription[i] + "\n";
                }
                break;
            default:
            }
            if (obj.type == undefined){
                var blnchecked = false;
                for (var j = 0; j < obj.length; j++){
                    if (obj[j].checked){
                        blnchecked = true;
                    }
                }
                if (!blnchecked){
                    alertMsg += " - " + fieldDescription[i] + "\n";
                }
            }
        }
    }
    if (alertMsg.length == l_Msg){
        return true;
    }else{
        alert(alertMsg);
        return false;
    }
}
// -->
</script>
<body onLoad="visibilitytoggle()"> <!-- This is required for the "Click'n'view" fct to work! -->
<div class="header">
<p class="logo"><a href="../../../doc/html/index.html"><img src="../../../doc/figures/oomph.png" alt="oomph-lib logo: Link to oomph-lib homepage" border=0></a></p>
<div class="head-section">
<div id="hotspot" name="hotspot" class="hotspot" 
     title="click to expand the navigation menu">Documentation,<br/>
     example codes and tutorials</div> 
<dl style="" id="toggle" name="toggle" class="toggle">  
<dt><a href="../../../doc/index/html/index.html">Index</a></dt>
<dt><a href="../../../doc/example_code_list/html/index.html">List of tutorials/demo codes</a></dt>
<dt><a href="../../../doc/quick_guide/html/index.html">The (Not-so) Quick Guide</a></dt>
<dt><a href="../../../doc/intro/html/index.html">FE theory and top-down discussion of the data structure</a></dt>
      <dt><a href="../../../doc/the_data_structure/html/index.html">Comprehensive bottom-up discussion of the data
      structure</a></dt>
      <dt><a href="../../../doc/paraview/html/index.html"> Visualisation of the results </a></dt>
      <dt><a href="../../../doc/coding_conventions/html/index.html">Coding conventions and C++ style</a></dt>
      <dt><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></dt>
      <dt><a href="../../../doc/optimisation/html/index.html">Optimisation</a>
      </dt> 
</dl>
</div><!-- end section-->
<div class="head-section">
<div id="hotspot" name="hotspot" class="hotspot" 
     title="click to expand the navigation menu">Parallel Processing</div> 
<dl style="" id="toggle" name="toggle" class="toggle">  
      <dt><a href="../../../doc/mpi/general_mpi/html/index.html"> Overview </a></dt>
     <dt><a href="../../../doc/mpi/distributed_linear_algebra_infrastructure/html/index.html">
     Distributed Linear Algebra </a></dt>
     <dt><a href="../../../doc/mpi/distributed_block_preconditioners/html/index.html">
     Distributed Block Preconditioners </a></dt>
     <dt><a href="../../../doc/mpi/distributed_general_purpose_block_preconditioners/html/index.html">
     Distributed General-Purpose Block Preconditioners </a></dt>
</dl>
</div>
<div class="head-section">
<div id="hotspot" name="hotspot" class="hotspot" 
     title="click to expand the navigation menu"> Publications</div> 
<dl style="" id="toggle" name="toggle" class="toggle">  
    <dt><a href="../../../doc/publications/html/index.html">Publications</a>
      <dd><a href="../../../doc/publications/html/index.html#talks">Talks</a></dd>
      <dd><a href="../../../doc/publications/html/index.html#papers">Journal publications</a></dd>
      <dd><a href="../../../doc/publications/html/index.html#theses">Theses</a></dd>
    </dt>
    <dt><a href="../../../doc/picture_show/index.html">Picture show </a></dt>
</dl>
</div><!-- end section-->
<div class="head-section">
<div id="hotspot" name="hotspot" class="hotspot" 
     title="click to expand the navigation menu"> Download</div> 
<dl style="" id="toggle" name="toggle" class="toggle">  
    <dt><a href="../../../doc/copyright/html/index.html">Copyright</a></dt>
    <dt><a href="../../../doc/the_distribution/html/index.html">Download/installation instructions</a></dt>
    <dt><a href="../../../doc/download/html/index.html">Download page</a></dt>
</dl>
</div><!-- end section-->
<div class="head-section">
<div id="hotspot" name="hotspot" class="hotspot" 
     title="click to expand the navigation menu">FAQ & Contact</div> 
<dl style="" id="toggle" name="toggle" class="toggle">  
    <dt><a href="../../../doc/FAQ/html/index.html">FAQ</a></dt>
    <dt><a href="../../../doc/change_log/html/index.html">Change log</a></dt>
    <dt><a href="../../../doc/bugs/html/index.html">Bugs and other known problems</a></dt>
    <dt><a href="../../../doc/ToDo/html/index.html">Completeness of the library & our "To-Do List" </a></dt>
    <dt><a href="../../../doc/contact/html/index.html">Contact the developers</a></dt>
    <dt><a href="../../../doc/get_involved/html/index.html">Get involved </a></dt>
</dl>
</div><!-- end section-->
<p class="clear">&nbsp;</p>
</div><!-- end header -->
<P>
<HR>
<TABLE BORDER=1, WIDTH=700px>
<TR>
<TD bgcolor="cornsilk">
<CENTER><B>Beta release!</b></CENTER><br>
Please note that the library has not been "officially" released.
While we continue to work on the documentation, these web pages
are likely to contain broken links and documents in draft form. 
Please send an email to 
<BR><BR>
<CENTER>
<TT>oomph-lib AT maths DOT man DOT ac DOT uk</TT>
</CENTER>
<BR> 
if you wish to be informed of the library's "official" release.
</TD>
</TR>
</TABLE>
</CENTER>
<HR>
<script type="text/javascript">
 function index_toggle(id,img) {
  var e = document.getElementById(id);
  var im = document.getElementById(img);
  if (e.style.display == '')
   {
      e.style.display = 'none';
      im.src="../expand.png";
   }
  else
   {
   e.style.display = '';
   im.src = "../collapse.png";
   }
 }
</script>
</head>
<!-- Generated by Doxygen 1.8.1.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Optimisation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>One of the main challenges in the development of a general-purpose scientific computing library is the potential conflict between the desire for robustness and generality on the one hand, and code optimisation (in terms of speed and memory requirements) on the other.</p>
<p>One of <code>oomph-lib's</code> main design principles is that</p>
<center> <em><b>Robustness/correctness is more important than "raw speed",</b></em> </center><p>implying that <em>by</em> <em>default</em>, all methods should reliably produce the <em>correct</em> results. Possible optimisations that may lead to incorrect results even for a small subset of cases, must be activated explicitly by the "knowledgeable" user, who then takes the responsibility for any resulting errors.</p>
<p>Here are some examples for possible optimisations that you may wish to activate for your problem.</p>
<ul>
<li><a class="el" href="index.html#linear_vs_nonlinear">Linear vs. nonlinear problems</a></li>
<li><a class="el" href="index.html#store_shape">Storing the shape functions</a></li>
<li><a class="el" href="index.html#full_integration">Full vs. reduced integration</a></li>
<li><a class="el" href="index.html#ale">Disabling the ALE formulation of unsteady equations</a></li>
<li><a class="el" href="index.html#C_style_output">C vs. C++-style output</a></li>
<li><a class="el" href="index.html#assembly">Different sparse assembly techniques and the STL memory pool</a></li>
</ul>
<p>All tend to lead to faster run times (by how much depends on your machine and your compiler &ndash; experiment!), but there are caveats that you must be aware of:</p>
<ul>
<li>Some techniques may incur signficant memory overheads (e.g. storing the shape functions).</li>
<li>Some techniques may produce the wrong results for your problem (for instance, declaring a problem to be linear when it isn't will lead to a very significant speedup. However, the results will be wrong!)</li>
<li>Some techniques will make the code less robust (e.g. using C-style output).</li>
</ul>
<p>You choose!</p>
<hr/>
 <hr/>
<h1><a class="anchor" id="linear_vs_nonlinear"></a>
Linear vs. nonlinear problems</h1>
<p>By default, <code>oomph-lib</code> treats all problems as nonlinear and uses Newton's method to solve the system of nonlinear algebraic equations that result from the problem's discretisation. With this approach, linear problems are special cases for which Newton's method converges in one step. However, if a problem is known to be linear, several (costly) steps in Newton's method are superfluous and may be omitted, leading to a significant speedup. For instance, in a linear problem it is not necessary to re-compute the residuals of the nonlinear algebraic equations after the (single) Newton step, as we already know that they will have been reduced to zero (modulo roundoff errors). We refer to the document <a href="../../order_of_action_functions/html/index.html">"Action" functions in oomph-lib's black-box Newton solver</a> for a more detailed discussion.</p>
<p>The user may declare a problem to be linear by setting the flag </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> Problem::Problem_is_nonlinear</div>
</div><!-- fragment --><p> which is initialised to <code>true</code> in the constructor of the <code>Problem</code> base class, to <code>false</code>.</p>
<p>Experiment with the demo code <a href="../../../demo_drivers/optimisation/linear_vs_nonlinear/two_d_poisson.cc">two_d_poisson.cc</a> to examine the speedup achievable by declaring a (linear!) Problem to be linear.</p>
<hr/>
 <hr/>
<h1><a class="anchor" id="store_shape"></a>
Storing the shape functions</h1>
<p>If a problem is to be solved repeatedly (e.g. in a time-dependent simulation, or during a parameter study) it may be beneficial to avoid the re-computation of the shape function and their derivatives with respect to the local and global coordinates at the elements' integration points by storing their values.</p>
<p>However, there are two problems with this approach:</p>
<ol type="1">
<li>It introduces significant memory overheads. For instance, to store just the shape functions in a 3D problem discretised by <img class="formulaInl" alt="$ N_{elem}$" src="form_0.png"/> 27-node brick elements with a 27-point Gauss rule, storage for <img class="formulaInl" alt="$ 27 \times 27 \times N_{elem} $" src="form_1.png"/> doubles is required. Storage of the (much more costly to compute) shape function derivatives requires six times that storage.</li>
<li>The most costly-to-compute quantities are the derivatives of the shape functions with respect to the global coordinates, so it is most tempting to store these. However, in free-boundary problems in which the nodal positions are determined as part of the solution, the derivatives of the shape functions with respect to the global coordinates depend on the solution and <b>must</b> be recomputed.</li>
</ol>
<p>To ensure correctness/robustness and to minimise the memory overheads, <code>oomph-lib's</code> existing finite elements represent the shape functions and their derivatives as <code>StorableShapeFunction</code> objects. These allow their values to be stored at the integration points, but the capability is not activated, unless an element (of type <code>ELEMENT</code>, say) is used in its "wrapped" form, as <code>StorableShapeElement&lt;ELEMENT&gt;</code>.</p>
<p>The detailed documentation for this is yet to be written but you may consult the well-documented demo code <a href="../../../demo_drivers/optimisation/stored_shape_fcts/two_d_poisson_stored_shape_fcts.cc">two_d_poisson_stored_shape_fcts.cc</a>, and the discussion in the <a href="../../quick_guide/html/index.html#pre_compute_psi">(Not-So-)Quick Guide.</a></p>
<hr/>
 <hr/>
<h1><a class="anchor" id="full_integration"></a>
Full vs. reduced integration</h1>
<p>To maximise the potential for code reuse, all existing finite elements in <code>oomph-lib</code> are composed (via multiple inheritance) from (i) "geometric" finite elements (e.g. line, quad, brick, triangle and tet elements), and (ii) separate equations classes. A default (spatial) integration scheme is defined for each geometric element. This default integration scheme is chosen to provide "full integration" for this element. This implies that for an undeformed element the products of any two shape functions are integrated exactly. For time-dependent problems (e.g. in problems involving the unsteady heat equation) where products of shape functions arise in the "mass matrix", "full integration" is required to ensure that the numerical solution converges to the exact solution under mesh refinement. In some applications (e.g. in problems involving the Poisson equation) a lower-order (and therefore cheaper) "reduced integration" scheme may be sufficient to maintain the asymptotic convergence rate.</p>
<p>In this case, the user can over-write the default spatial integration scheme, using the function <code>FiniteElement::set_integration_scheme</code>(...), as illustrated here. </p>
<div class="fragment"><div class="line"> <span class="comment">// Create an instance of a lower-order integration scheme</span></div>
<div class="line"> Gauss&lt;2,2&gt;* int_pt=<span class="keyword">new</span> Gauss&lt;2,2&gt;;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Find number of elements in mesh</span></div>
<div class="line"><span class="keywordtype">unsigned</span> n_element = problem.mesh_pt()-&gt;nelement();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Loop over the elements </span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Set the a different integration scheme</span></div>
<div class="line">  problem.mesh_pt()-&gt;finite_element_pt(i)-&gt;set_integration_scheme(int_pt); </div>
<div class="line"> }</div>
</div><!-- fragment --><p>Driver codes that may be used to experiment with reduced integration and to assess the asymptotic convergence behaviour can be found in the directory <a href="../../../self_test/poisson/convergence_tests">self_test/poisson/convergence_tests/</a> <hr/>
 <hr/>
<h1><a class="anchor" id="ale"></a>
Disabling the ALE formulation of unsteady equations</h1>
<p>Most existing finite elements for unsteady problems are formulated in the "Arbitrary Lagrangian Eulerian (ALE)" form by implementing the Eulerian time-derivative <img class="formulaInl" alt="$ \partial u /\partial t$" src="form_2.png"/> (to be evaluated at a fixed Eulerian position) as </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. \frac{\partial u}{\partial t} \right|_{\mbox{fixed Eulerian position}} = \left. \frac{\partial u}{\partial t} \right|_{\mbox{fixed local coordinate}} - \sum_{i=1}^{DIM} v_i^{\mbox{[Mesh]}} \ \frac{\partial u}{\partial x_i} \]" src="form_3.png"/>
</p>
<p> where <img class="formulaInl" alt="$ v_i^{\mbox{[Mesh]}} \ \ (i=1,...,DIM)$" src="form_4.png"/> is the mesh velocity. This formulation ensures that the time-derivatives are computed correctly if the element is used in a free-boundary value problem. However, the computation of the mesh velocities introduces an additional cost which is avoidable if the mesh is, in fact, stationary. The user may disable the computation of the ALE terms by calling the function </p>
<div class="fragment"><div class="line">FiniteElement::disable_ALE()</div>
</div><!-- fragment --><p> (This function is implemented as a virtual function in the <code>FiniteElement</code> base class. If called, it simply issues a warning message to announce that it has not been overloaded in a derived class &ndash; usually an indication that the element in question does not involve any ALE terms). The ALE capability may be re-enabled by calling the corresponding function </p>
<div class="fragment"><div class="line">FiniteElement::enable_ALE()</div>
</div><!-- fragment --><p>Experiment with the driver codes in the directory <a href="../../../demo_drivers/optimisation/disable_ALE">demo_drivers/optimisation/disable_ALE</a> to examine the speedup achievable by ignoring the ALE terms in the <a href="../../../demo_drivers/optimisation/disable_ALE/unsteady_heat">unsteady heat</a> and <a href="../../../demo_drivers/optimisation/disable_ALE/navier_stokes">Navier-Stokes</a> equations.</p>
<hr/>
 <hr/>
<h1><a class="anchor" id="C_style_output"></a>
C vs. C++-style output</h1>
<p>In most <a href="../../example_code_list/html/index.html">demo driver codes</a> post-processing is performed by passing a C++-stream to a high-level output function, as in this code segment </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;ofstream&gt;</span></div>
<div class="line"></div>
<div class="line">[...]</div>
<div class="line"></div>
<div class="line">ofstream output_stream(<span class="stringliteral">&quot;solution.dat&quot;</span>);</div>
<div class="line">mesh_pt()-&gt;output(output_stream);</div>
<div class="line">output_stream.close();</div>
<div class="line"></div>
<div class="line">[...]</div>
</div><!-- fragment --><p>While C++-streams are very convenient, they can be expensive &ndash; so much so that in extreme cases a computation can become dominated by the cost of the post-processing operations. There is no obvious reason why I/O with C++ streams should be so much slower than I/O in fortran or C, say. In fact, it is not supposed to be! (Google will lead you to numerous heated discussions on this topic.) However, we (and, it seems, many others) have found C++-output to be consistently slower than C-style output. Since the latter is available from C++ we have started to provide alternative output routines that employ C-style I/O, using the FILE type. If your computation involves lots of I/O, it may be helpful to replace the above statements by</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;stdio.h&gt;</span></div>
<div class="line"></div>
<div class="line">[...]</div>
<div class="line"></div>
<div class="line">FILE* file_pt = fopen(<span class="stringliteral">&quot;solution.dat&quot;</span>,<span class="stringliteral">&quot;w&quot;</span>);</div>
<div class="line">mesh_pt()-&gt;output(file_pt);</div>
<div class="line">fclose(file_pt);</div>
<div class="line"></div>
<div class="line">[...]</div>
</div><!-- fragment --><p>Depending on the application, we typically find that C-style output is about 2 to 6 times faster than its C++ equivalent. Run the demo code <a href="../../../demo_drivers/optimisation/C_style_output/c_style_output.cc">c_style_output.cc</a> to explore the relative performance of the two methods on your machine. However, C-style output is not as "bullet-proof" as its C++-counterpart. For instance, if an output directory does not exist, trying to write to it with C-style output tends to cause a segmentation fault, whereas C++-output handles this more gracefully (no output is produced but the code execution continues).</p>
<hr/>
 <hr/>
<h1><a class="anchor" id="assembly"></a>
Different sparse assembly techniques and the STL memory pool</h1>
<h2><a class="anchor" id="assembly_methods"></a>
The different sparse assembly methods and how to compare their relative performance</h2>
<p><code>oomph-lib's</code> black-box nonlinear solver <code>Problem::newton_solve()</code> employs Newton's method to solve the system of nonlinear algebraic equations arising from the discretisation of the problem. By default, the linear systems that determine the corrections to the unknowns during the Newton iterations are solved with <code>SuperLUSolver</code>, <code>oomph-lib's</code> default <code>LinearSolver</code>. Within this framework the two most computationally expensive steps (both in terms of memory usage and CPU time) are the assembly of the linear system (comprising the Jacobian matrix and the residual vector) and its solution. [Not all of <code>oomph-lib's</code> <code>LinearSolvers</code> require the assembly of the Jacobian matrix (for instance the frontal solver <code>HSL_MA42</code> avoids the assembly of the linear system and computes its LU decomposition "on the fly") but most of them do.]</p>
<p>The assembly of the Jacobian matrix (in compressed-row or compressed-column storage) is typically performed by the function</p>
<div class="fragment"><div class="line">Problem::sparse_assemble_row_or_column_compressed(...)</div>
</div><!-- fragment --><p>This function performs the assembly, using one of five different assembly methods, selected by the protected member data</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> Problem::Sparse_assembly_method</div>
</div><!-- fragment --><p>in the <code>Problem</code> class. This flag can take any of the values defined in the enumeration <code>Problem::Assembly_method</code>.</p>
<p>Each of the five different methods has its own advantages and disadvantages in terms of speed and/or memory requirements. By default, we use the "assembly using vectors of pairs" as it tends to be optimal in both respects &ndash; at least when the library is compiled with full optimisation. If the library is compiled without optimsation and/or in <code>PARANOID</code> mode, the map-based assembly tends to be faster, if significantly more expensive in terms of memory requirements.</p>
<p>You should explore the performance of the various methods on your machine, using the the driver code <a href="../../../demo_drivers/optimisation/sparse_assemble/sparse_assemble_test.cc">sparse_assemble_test.cc</a> in the directory</p>
<center> <a href="../../../demo_drivers/optimisation/sparse_assemble/">demo_drivers/optimisation/sparse_assemble</a> </center><p>The shell script <a href="../../../demo_drivers/optimisation/sparse_assemble/compare.bash">compare.bash</a> in the same directory may be used to systematically explore the performance of the different methods for various problem sizes.</p>
<p>While the test code automatically documents the CPU times required for the matrix assembly, the automatic assessment of its memory usage is a somewhat nontrivial task. We provide a quick-and-dirty solution to this problem: If the protected member data</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> Problem::Pause_at_end_of_sparse_assembly</div>
</div><!-- fragment --><p>is set to true, the assembly process is halted when it has reached its most memory-intensive phase. The user can then use <code>top</code> (or some other external tool) to assess the memory usage of the code. (Typing "M" in <code>top</code> sorts the entries by memory usage rather than by cpu usage).</p>
<hr/>
<h2><a class="anchor" id="STL_pool"></a>
The STL memory pool</h2>
<p>When analysing the code's memory usage, you may notice that, following the assembly of the Jacobian matrix, not all memory is returned to the system, particularly, if maps or lists are used for the assembly. This does <b>not</b> indicate the presence of a memory leak but is a result of the internal memory management performed by the STL allocator which retains some (and in some cases a lot) of the initially allocated memory in its own "memory pool" in order to speed up the subsequent memory allocation for other STL objects. <a href="http://www.google.com">Google</a> for "STL memory pool" to find out more about this issue. The executive summary is: "Memory pools are good for you", even though they have the slightly annoying side-effect of making it virtually impossible to monitor the <em>actual</em> memory usage of the code.</p>
<hr/>
 <hr/>
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 22 2012 19:07:51 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
